library.jkipm.in/BookReturn.aspx
Admin-username
123456- Pass 

https://suttoncoldfieldhinduassociation.elpimo.com/


------------------------------
Add Table In  JK Table 
Notes For table 

CREATE TABLE Books (
    BookId INT PRIMARY KEY IDENTITY(1,1),
    IsbnNumber VARCHAR(20) NOT NULL,
    Title NVARCHAR(255) NOT NULL,
    Barcode NVARCHAR(100),
    Author NVARCHAR(255),
    BookPhoto NVARCHAR(500),
    Details TEXT,
    CourseId INT,
    Price DECIMAL(10, 2),
    SubjectId INT,
    PublicationId INT,
    IsAvailable BIT DEFAULT 1,
    TotalCopies INT DEFAULT 1,
    AvailableCopies INT DEFAULT 1,
    Edition NVARCHAR(50),
    Language NVARCHAR(50),
    PublishedYear INT,
    IsActive BIT DEFAULT 1,
    CreatedBy NVARCHAR(100),
    CreatedOn DATETIME DEFAULT GETDATE(),
    ModifiedBy NVARCHAR(100),
    ModifiedOn DATETIME,

    -- Corrected Foreign Key Constraints
    CONSTRAINT FK_Books_Subject FOREIGN KEY (SubjectId) REFERENCES Subject(SubId),
    CONSTRAINT FK_Books_Publication FOREIGN KEY (PublicationId) REFERENCES Publication(PubId),
    CONSTRAINT FK_Books_Course FOREIGN KEY (CourseId) REFERENCES Course(id)
);


CREATE TABLE BookIssue (
    IssueId INT PRIMARY KEY IDENTITY(1,1),
    BookId INT NOT NULL,
    StudentId INT NOT NULL,
    IssueDate DATETIME NOT NULL,
    DueDate DATETIME NOT NULL,
    ReturnDate DATETIME,
    Remarks TEXT,
    Status NVARCHAR(20) CHECK (Status IN ('issued', 'returned', 'overdue')),
    PenaltyId INT, -- Optional FK if you have Penalty table
    IsRenewed BIT DEFAULT 0,
    CreatedBy NVARCHAR(100),
    CreatedOn DATETIME DEFAULT GETDATE(),
    ModifiedBy NVARCHAR(100),
    ModifiedOn DATETIME,

    -- Foreign Key Constraints
    CONSTRAINT FK_BookIssue_Book FOREIGN KEY (BookId) REFERENCES Books(BookId),
    CONSTRAINT FK_BookIssue_Student FOREIGN KEY (StudentId) REFERENCES Student(id)
    -- If you have a Penalty table:
    -- , CONSTRAINT FK_BookIssue_Penalty FOREIGN KEY (PenaltyId) REFERENCES Penalty(PenaltyId)
);

import { NextRequest, NextResponse } from 'next/server';
import { getConnection } from '@/app/lib/db';
import logger from '@/app/lib/logger';
import fs from 'fs';
import path from 'path';

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const search = searchParams.get('search') || '';
    const status = searchParams.get('status') || 'all';
    const courseId = searchParams.get('courseId') || '';
    const subjectId = searchParams.get('subjectId') || '';
    const publicationId = searchParams.get('publicationId') || '';
    const availability = searchParams.get('availability') || 'all';

    const pool = await getConnection();
    
    let query = `
      SELECT b.*, 
        c.courseName AS CourseName,
        s.Name AS SubjectName,
        p.Name AS PublicationName
      FROM Books b
      LEFT JOIN Course c ON b.CourseId = c.id
      LEFT JOIN Subject s ON b.SubjectId = s.SubId
      LEFT JOIN Publication p ON b.PublicationId = p.PubId
      WHERE (b.Title LIKE @search OR b.IsbnNumber LIKE @search OR b.Author LIKE @search)
    `;
    
    const params: any = { 
      search: `%${search}%`,
      courseId: courseId ? parseInt(courseId) : null,
      subjectId: subjectId ? parseInt(subjectId) : null,
      publicationId: publicationId ? parseInt(publicationId) : null
    };

    if (status !== 'all') {
      query += ' AND b.IsActive = @isActive';
      params.isActive = status === 'active' ? 1 : 0;
    }

    if (courseId) {
      query += ' AND b.CourseId = @courseId';
    }

    if (subjectId) {
      query += ' AND b.SubjectId = @subjectId';
    }

    if (publicationId) {
      query += ' AND b.PublicationId = @publicationId';
    }

    if (availability !== 'all') {
      if (availability === 'available') {
        query += ' AND b.AvailableCopies > 0';
      } else {
        query += ' AND b.AvailableCopies = 0';
      }
    }

    query += ' ORDER BY b.Title';

    const result = await pool.request()
      .input('search', params.search)
      .input('isActive', params.isActive)
      .input('courseId', params.courseId)
      .input('subjectId', params.subjectId)
      .input('publicationId', params.publicationId)
      .query(query);

    return NextResponse.json(result.recordset);
  } catch (error) {
    logger.error(`Error fetching books: ${error}`);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();
    
    const title = formData.get('Title') as string;
    const isbnNumber = formData.get('IsbnNumber') as string;
    const barcode = formData.get('Barcode') as string;
    const author = formData.get('Author') as string;
    const details = formData.get('Details') as string;
    const courseId = formData.get('CourseId') as string;
    const price = formData.get('Price') as string;
    const subjectId = formData.get('SubjectId') as string;
    const publicationId = formData.get('PublicationId') as string;
    const totalCopies = formData.get('TotalCopies') as string;
    const edition = formData.get('Edition') as string;
    const language = formData.get('Language') as string;
    const publishedYear = formData.get('PublishedYear') as string;
    const createdBy = formData.get('CreatedBy') as string;
    const bookPhoto = formData.get('BookPhoto') as File | null;

    // Validate required fields
    if (!title || !isbnNumber) {
      return NextResponse.json({ message: 'Title and ISBN are required' }, { status: 400 });
    }

    let bookPhotoPath = '';
    if (bookPhoto && bookPhoto.size > 0) {
      try {
        // Create books directory if it doesn't exist
        const uploadDir = path.join(process.cwd(), 'public', 'books');
        if (!fs.existsSync(uploadDir)) {
          fs.mkdirSync(uploadDir, { recursive: true });
        }

        // Generate unique filename
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
        const extension = bookPhoto.name.split('.').pop();
        const filename = `book-${uniqueSuffix}.${extension}`;
        bookPhotoPath = `/books/${filename}`;

        // Write file to disk
        const filePath = path.join(uploadDir, filename);
        const fileBuffer = await bookPhoto.arrayBuffer();
        fs.writeFileSync(filePath, Buffer.from(fileBuffer));
      } catch (error) {
        logger.error(`Error saving book photo: ${error}`);
        return NextResponse.json({ message: 'Error saving book photo' }, { status: 500 });
      }
    }

    const pool = await getConnection();
    
    // Check if ISBN already exists
    const checkResult = await pool.request()
      .input('IsbnNumber', isbnNumber)
      .query('SELECT * FROM Books WHERE IsbnNumber = @IsbnNumber');

    if (checkResult.recordset.length > 0) {
      return NextResponse.json({ message: 'Book with this ISBN already exists' }, { status: 400 });
    }

    await pool.request()
      .input('IsbnNumber', isbnNumber)
      .input('Title', title)
      .input('Barcode', barcode || null)
      .input('Author', author || null)
      .input('BookPhoto', bookPhotoPath || null)
      .input('Details', details || null)
      .input('CourseId', courseId ? parseInt(courseId) : null)
      .input('Price', price ? parseFloat(price) : null)
      .input('SubjectId', subjectId ? parseInt(subjectId) : null)
      .input('PublicationId', publicationId ? parseInt(publicationId) : null)
      .input('TotalCopies', totalCopies ? parseInt(totalCopies) : 1)
      .input('AvailableCopies', totalCopies ? parseInt(totalCopies) : 1)
      .input('Edition', edition || null)
      .input('Language', language || null)
      .input('PublishedYear', publishedYear ? parseInt(publishedYear) : null)
      .input('CreatedBy', createdBy || 'admin')
      .query(`
        INSERT INTO Books (
          IsbnNumber, Title, Barcode, Author, BookPhoto, Details, CourseId, Price, 
          SubjectId, PublicationId, TotalCopies, AvailableCopies, Edition, 
          Language, PublishedYear, CreatedBy
        ) VALUES (
          @IsbnNumber, @Title, @Barcode, @Author, @BookPhoto, @Details, @CourseId, @Price,
          @SubjectId, @PublicationId, @TotalCopies, @AvailableCopies, @Edition,
          @Language, @PublishedYear, @CreatedBy
        )
      `);

    return NextResponse.json({ message: 'Book added successfully' });
  } catch (error) {
    logger.error(`Error adding book: ${error}`);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const formData = await req.formData();
    
    const bookId = formData.get('BookId') as string;
    const title = formData.get('Title') as string;
    const isbnNumber = formData.get('IsbnNumber') as string;
    const barcode = formData.get('Barcode') as string;
    const author = formData.get('Author') as string;
    const details = formData.get('Details') as string;
    const courseId = formData.get('CourseId') as string;
    const price = formData.get('Price') as string;
    const subjectId = formData.get('SubjectId') as string;
    const publicationId = formData.get('PublicationId') as string;
    const totalCopies = formData.get('TotalCopies') as string;
    const edition = formData.get('Edition') as string;
    const language = formData.get('Language') as string;
    const publishedYear = formData.get('PublishedYear') as string;
    const modifiedBy = formData.get('ModifiedBy') as string;
    const isActive = formData.get('IsActive') as string;
    const bookPhoto = formData.get('BookPhoto') as File | null;
    const currentPhotoPath = formData.get('CurrentPhotoPath') as string | null;

    // Validate required fields
    if (!bookId || !title || !isbnNumber) {
      return NextResponse.json({ message: 'Book ID, Title and ISBN are required' }, { status: 400 });
    }

    let bookPhotoPath = currentPhotoPath || '';
    if (bookPhoto && bookPhoto.size > 0) {
      try {
        // Create books directory if it doesn't exist
        const uploadDir = path.join(process.cwd(), 'public', 'books');
        if (!fs.existsSync(uploadDir)) {
          fs.mkdirSync(uploadDir, { recursive: true });
        }

        // Delete old photo if exists
        if (currentPhotoPath) {
          const oldFilePath = path.join(process.cwd(), 'public', currentPhotoPath);
          if (fs.existsSync(oldFilePath)) {
            fs.unlinkSync(oldFilePath);
          }
        }

        // Generate unique filename
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
        const extension = bookPhoto.name.split('.').pop();
        const filename = `book-${uniqueSuffix}.${extension}`;
        bookPhotoPath = `/books/${filename}`;

        // Write file to disk
        const filePath = path.join(uploadDir, filename);
        const fileBuffer = await bookPhoto.arrayBuffer();
        fs.writeFileSync(filePath, Buffer.from(fileBuffer));
      } catch (error) {
        logger.error(`Error saving book photo: ${error}`);
        return NextResponse.json({ message: 'Error saving book photo' }, { status: 500 });
      }
    }

    const pool = await getConnection();
    
    // Check if ISBN already exists for another book
    const checkResult = await pool.request()
      .input('IsbnNumber', isbnNumber)
      .input('BookId', parseInt(bookId))
      .query('SELECT * FROM Books WHERE IsbnNumber = @IsbnNumber AND BookId != @BookId');

    if (checkResult.recordset.length > 0) {
      return NextResponse.json({ message: 'Another book with this ISBN already exists' }, { status: 400 });
    }

    await pool.request()
      .input('BookId', parseInt(bookId))
      .input('IsbnNumber', isbnNumber)
      .input('Title', title)
      .input('Barcode', barcode || null)
      .input('Author', author || null)
      .input('BookPhoto', bookPhotoPath || null)
      .input('Details', details || null)
      .input('CourseId', courseId ? parseInt(courseId) : null)
      .input('Price', price ? parseFloat(price) : null)
      .input('SubjectId', subjectId ? parseInt(subjectId) : null)
      .input('PublicationId', publicationId ? parseInt(publicationId) : null)
      .input('TotalCopies', totalCopies ? parseInt(totalCopies) : 1)
      .input('Edition', edition || null)
      .input('Language', language || null)
      .input('PublishedYear', publishedYear ? parseInt(publishedYear) : null)
      .input('ModifiedBy', modifiedBy || 'admin')
      .input('IsActive', isActive === 'true' ? 1 : 0)
      .query(`
        UPDATE Books SET
          IsbnNumber = @IsbnNumber,
          Title = @Title,
          Barcode = @Barcode,
          Author = @Author,
          BookPhoto = @BookPhoto,
          Details = @Details,
          CourseId = @CourseId,
          Price = @Price,
          SubjectId = @SubjectId,
          PublicationId = @PublicationId,
          TotalCopies = @TotalCopies,
          Edition = @Edition,
          Language = @Language,
          PublishedYear = @PublishedYear,
          ModifiedBy = @ModifiedBy,
          ModifiedOn = GETDATE(),
          IsActive = @IsActive
        WHERE BookId = @BookId
      `);

    return NextResponse.json({ message: 'Book updated successfully' });
  } catch (error) {
    logger.error(`Error updating book: ${error}`);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { BookId } = await req.json();
    
    if (!BookId) {
      return NextResponse.json({ message: 'Book ID is required' }, { status: 400 });
    }

    const pool = await getConnection();
    
    // First get the book photo path to delete it
    const bookResult = await pool.request()
      .input('BookId', BookId)
      .query('SELECT BookPhoto FROM Books WHERE BookId = @BookId');

    if (bookResult.recordset.length === 0) {
      return NextResponse.json({ message: 'Book not found' }, { status: 404 });
    }

    const bookPhotoPath = bookResult.recordset[0].BookPhoto;
    
    // Delete the photo if exists
    if (bookPhotoPath) {
      try {
        const filePath = path.join(process.cwd(), 'public', bookPhotoPath);
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
      } catch (error) {
        logger.error(`Error deleting book photo: ${error}`);
        // Continue with book deletion even if photo deletion fails
      }
    }

    // Delete the book
    await pool.request()
      .input('BookId', BookId)
      .query('DELETE FROM Books WHERE BookId = @BookId');

    return NextResponse.json({ message: 'Book deleted successfully' });
  } catch (error) {
    logger.error(`Error deleting book: ${error}`);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
----------------------------------------------------------


'use client';

import { useEffect, useState, useRef } from 'react';
import { toast } from 'react-toastify';
import axios from 'axios';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { 
  faSpinner, 
  faEye, 
  faEyeSlash, 
  faArrowLeft, 
  faPlus, 
  faEdit, 
  faTrash, 
  faSearch, 
  faFilter,
  faBook,
  faBarcode,
  faUser,
  faInfoCircle,
  faMoneyBillWave,
  faCalendar,
  faLanguage,
  faImage
} from '@fortawesome/free-solid-svg-icons';

interface Book {
  BookId: number;
  IsbnNumber: string;
  Title: string;
  Barcode: string;
  Author: string;
  BookPhoto: string;
  Details: string;
  CourseId: number;
  CourseName: string;
  Price: number;
  SubjectId: number;
  SubjectName: string;
  PublicationId: number;
  PublicationName: string;
  IsAvailable: boolean;
  TotalCopies: number;
  AvailableCopies: number;
  Edition: string;
  Language: string;
  PublishedYear: number;
  IsActive: boolean;
  CreatedBy: string;
  CreatedOn: string;
  ModifiedBy: string;
  ModifiedOn: string;
}

interface Course {
  id: number;
  courseName: string;
}

interface Subject {
  SubId: number;
  Name: string;
}

interface Publication {
  PubId: number;
  Name: string;
}

const BooksPage = () => {
  const [books, setBooks] = useState<Book[]>([]);
  const [courses, setCourses] = useState<Course[]>([]);
  const [subjects, setSubjects] = useState<Subject[]>([]);
  const [publications, setPublications] = useState<Publication[]>([]);
  const [loading, setLoading] = useState(true);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
  const [confirmAction, setConfirmAction] = useState<'delete' | 'toggle' | null>(null);
  const [confirmId, setConfirmId] = useState<number | null>(null);
  const [currentBook, setCurrentBook] = useState<Partial<Book> | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [statusFilter, setStatusFilter] = useState<'all' | 'active' | 'inactive'>('all');
  const [availabilityFilter, setAvailabilityFilter] = useState<'all' | 'available' | 'unavailable'>('all');
  const [courseFilter, setCourseFilter] = useState<string>('');
  const [subjectFilter, setSubjectFilter] = useState<string>('');
  const [publicationFilter, setPublicationFilter] = useState<string>('');
  const [photoPreview, setPhotoPreview] = useState<string | null>(null);
  const [photoFile, setPhotoFile] = useState<File | null>(null);
  const [filteredSubjects, setFilteredSubjects] = useState<Subject[]>([]);

  const fileInputRef = useRef<HTMLInputElement>(null);
  const modalRef = useRef<HTMLDivElement>(null);
  const confirmModalRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    fetchBooks();
    fetchCourses();
    fetchSubjects();
    fetchPublications();
  }, []);

  useEffect(() => {
    if (currentBook?.CourseId) {
      const filtered = subjects.filter(subject => 
        subject.SubId === currentBook.SubjectId || 
        !books.some(b => b.SubjectId === subject.SubId && b.CourseId === currentBook.CourseId)
      );
      setFilteredSubjects(filtered);
    } else {
      setFilteredSubjects(subjects);
    }
  }, [currentBook?.CourseId, subjects, books]);

  const fetchBooks = async () => {
    setLoading(true);
    try {
      const params = { 
        search: searchTerm, 
        status: statusFilter,
        availability: availabilityFilter,
        courseId: courseFilter,
        subjectId: subjectFilter,
        publicationId: publicationFilter
      };
      const res = await axios.get('/api/admin/api/book', { params });
      setBooks(res.data);
    } catch (error) {
      toast.error('Failed to fetch books');
    } finally {
      setLoading(false);
    }
  };

  const fetchCourses = async () => {
    try {
      const res = await axios.get('/api/course');
      setCourses(res.data);
    } catch (error) {
      toast.error('Failed to fetch courses');
    }
  };

  const fetchSubjects = async () => {
    try {
      const res = await axios.get('/api/subject');
      setSubjects(res.data);
      setFilteredSubjects(res.data);
    } catch (error) {
      toast.error('Failed to fetch subjects');
    }
  };

  const fetchPublications = async () => {
    try {
      const res = await axios.get('/api/publication');
      setPublications(res.data);
    } catch (error) {
      toast.error('Failed to fetch publications');
    }
  };

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    fetchBooks();
  };

  const resetFilters = () => {
    setSearchTerm('');
    setStatusFilter('all');
    setAvailabilityFilter('all');
    setCourseFilter('');
    setSubjectFilter('');
    setPublicationFilter('');
    fetchBooks();
  };

  const openAddModal = () => {
    setCurrentBook({
      IsbnNumber: '',
      Title: '',
      Barcode: '',
      Author: '',
      BookPhoto: '',
      Details: '',
      CourseId: undefined,
      Price: undefined,
      SubjectId: undefined,
      PublicationId: undefined,
      TotalCopies: 1,
      Edition: '',
      Language: '',
      PublishedYear: undefined,
      IsActive: true
    });
    setPhotoPreview(null);
    setPhotoFile(null);
    setIsModalOpen(true);
  };

  const openEditModal = (book: Book) => {
    setCurrentBook(book);
    setPhotoPreview(book.BookPhoto ? `/books/${book.BookPhoto}` : null);
    setPhotoFile(null);
    setIsModalOpen(true);
  };

  const handlePhotoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      setPhotoFile(file);
      
      const reader = new FileReader();
      reader.onloadend = () => {
        setPhotoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const removePhoto = () => {
    setPhotoPreview(null);
    setPhotoFile(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
    if (currentBook) {
      setCurrentBook({ ...currentBook, BookPhoto: '' });
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!currentBook?.Title || !currentBook?.IsbnNumber) {
      toast.error('Title and ISBN are required');
      return;
    }

    const formData = new FormData();
    formData.append('Title', currentBook.Title);
    formData.append('IsbnNumber', currentBook.IsbnNumber);
    if (currentBook.Barcode) formData.append('Barcode', currentBook.Barcode);
    if (currentBook.Author) formData.append('Author', currentBook.Author);
    if (currentBook.Details) formData.append('Details', currentBook.Details);
    if (currentBook.CourseId) formData.append('CourseId', currentBook.CourseId.toString());
    if (currentBook.Price) formData.append('Price', currentBook.Price.toString());
    if (currentBook.SubjectId) formData.append('SubjectId', currentBook.SubjectId.toString());
    if (currentBook.PublicationId) formData.append('PublicationId', currentBook.PublicationId.toString());
    if (currentBook.TotalCopies) formData.append('TotalCopies', currentBook.TotalCopies.toString());
    if (currentBook.Edition) formData.append('Edition', currentBook.Edition);
    if (currentBook.Language) formData.append('Language', currentBook.Language);
    if (currentBook.PublishedYear) formData.append('PublishedYear', currentBook.PublishedYear.toString());
    formData.append('CreatedBy', 'admin');
    
    if (currentBook.BookId) {
      formData.append('BookId', currentBook.BookId.toString());
      formData.append('ModifiedBy', 'admin');
      formData.append('IsActive', currentBook.IsActive?.toString() || 'true');
      if (currentBook.BookPhoto) formData.append('CurrentPhotoPath', currentBook.BookPhoto);
    }

    if (photoFile) {
      formData.append('BookPhoto', photoFile);
    }

    try {
      const method = currentBook.BookId ? 'put' : 'post';
      const res = await axios({
        method,
        url: '/api/admin/api/book',
        data: formData,
        headers: {
          'Content-Type': 'multipart/form-data'
        }
      });

      toast.success(res.data.message);
      setIsModalOpen(false);
      fetchBooks();
    } catch (error: any) {
      const errorMsg = error.response?.data?.message || 'An error occurred';
      toast.error(errorMsg);
    }
  };

  const openConfirmModal = (action: 'delete' | 'toggle', id: number) => {
    setConfirmAction(action);
    setConfirmId(id);
    setIsConfirmModalOpen(true);
  };

  const handleConfirmAction = async () => {
    if (!confirmId) return;

    try {
      if (confirmAction === 'delete') {
        await axios.delete('/api/admin/api/book', { data: { BookId: confirmId } });
        toast.success('Book deleted successfully');
      } else {
        const book = books.find(b => b.BookId === confirmId);
        if (book) {
          await axios.put('/api/admin/api/book', {
            BookId: confirmId,
            Title: book.Title,
            IsbnNumber: book.IsbnNumber,
            IsActive: !book.IsActive,
            ModifiedBy: 'admin'
          });
          toast.success(`Book ${book.IsActive ? 'deactivated' : 'activated'}`);
        }
      }
      setIsConfirmModalOpen(false);
      fetchBooks();
    } catch (error) {
      toast.error('An error occurred');
    }
  };

  const handleCourseChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    const courseId = parseInt(e.target.value);
    setCurrentBook({
      ...currentBook,
      CourseId: courseId,
      SubjectId: undefined // Reset subject when course changes
    });
  };

  return (
    <div className="container mx-auto p-4">
      <div className="bg-white rounded-lg shadow-sm p-4">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 gap-4">
          <h2 className="text-xl font-semibold text-gray-800">Manage Books</h2>
          <button
            onClick={openAddModal}
            className="bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium py-2 px-4 rounded flex items-center gap-2"
          >
            <FontAwesomeIcon icon={faPlus} /> Add Book
          </button>
        </div>

        {/* Search and Filters */}
        <div className="bg-gray-50 p-4 rounded-lg mb-4">
          <form onSubmit={handleSearch} className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-4 gap-4">
            <div className="relative">
              <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                <FontAwesomeIcon icon={faSearch} className="text-gray-400" />
              </div>
              <input
                type="text"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                placeholder="Search books..."
                className="pl-10 pr-4 py-2 border border-gray-300 rounded-md w-full focus:outline-none focus:ring-2 focus:ring-blue-500"
              />
            </div>

            <div className="grid grid-cols-2 gap-2">
              <select
                value={statusFilter}
                onChange={(e) => setStatusFilter(e.target.value as 'all' | 'active' | 'inactive')}
                className="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="all">All Status</option>
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
              </select>

              <select
                value={availabilityFilter}
                onChange={(e) => setAvailabilityFilter(e.target.value as 'all' | 'available' | 'unavailable')}
                className="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="all">All Availability</option>
                <option value="available">Available</option>
                <option value="unavailable">Unavailable</option>
              </select>
            </div>

            <div className="grid grid-cols-3 gap-2">
              <select
                value={courseFilter}
                onChange={(e) => setCourseFilter(e.target.value)}
                className="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">All Courses</option>
                {courses.map((course) => (
                  <option key={course.id} value={course.id}>{course.courseName}</option>
                ))}
              </select>

              <select
                value={subjectFilter}
                onChange={(e) => setSubjectFilter(e.target.value)}
                className="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">All Subjects</option>
                {subjects.map((subject) => (
                  <option key={subject.SubId} value={subject.SubId}>{subject.Name}</option>
                ))}
              </select>

              <select
                value={publicationFilter}
                onChange={(e) => setPublicationFilter(e.target.value)}
                className="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">All Publications</option>
                {publications.map((pub) => (
                  <option key={pub.PubId} value={pub.PubId}>{pub.Name}</option>
                ))}
              </select>
            </div>

            <div className="flex gap-2">
              <button
                type="submit"
                className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md flex items-center gap-2"
              >
                <FontAwesomeIcon icon={faFilter} /> Apply Filters
              </button>
              <button
                type="button"
                onClick={resetFilters}
                className="bg-gray-200 hover:bg-gray-300 text-gray-800 px-4 py-2 rounded-md"
              >
                Reset
              </button>
            </div>
          </form>
        </div>

        {/* Books Table */}
        <div className="overflow-x-auto rounded-lg border border-gray-200">
          {loading ? (
            <div className="flex justify-center items-center p-8">
              <FontAwesomeIcon icon={faSpinner} className="animate-spin text-blue-500 text-2xl" />
            </div>
          ) : books.length === 0 ? (
            <div className="text-center p-8 text-gray-500">
              No books found
            </div>
          ) : (
            <table className="min-w-full divide-y divide-gray-200">
              <thead className="bg-gray-50">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cover</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Title</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Author</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">ISBN</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Course</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Available</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                </tr>
              </thead>
              <tbody className="bg-white divide-y divide-gray-200">
                {books.map((book) => (
                  <tr key={book.BookId} className="hover:bg-gray-50">
                    <td className="px-6 py-4 whitespace-nowrap">
                      {book.BookPhoto ? (
                        <img 
                          src={`/books/${book.BookPhoto}`} 
                          alt={book.Title} 
                          className="h-12 w-10 object-cover rounded"
                          onError={(e) => {
                            (e.target as HTMLImageElement).src = '/book-placeholder.png';
                          }}
                        />
                      ) : (
                        <div className="h-12 w-10 bg-gray-200 flex items-center justify-center rounded">
                          <FontAwesomeIcon icon={faBook} className="text-gray-400" />
                        </div>
                      )}
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm font-medium text-gray-900">{book.Title}</div>
                      <div className="text-sm text-gray-500">{book.Edition} {book.PublishedYear && `(${book.PublishedYear})`}</div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{book.Author}</td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{book.IsbnNumber}</td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <div className="text-sm text-gray-900">{book.CourseName}</div>
                      <div className="text-sm text-gray-500">{book.SubjectName}</div>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                        book.AvailableCopies > 0 ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                      }`}>
                        {book.AvailableCopies}/{book.TotalCopies}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap">
                      <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                        book.IsActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                      }`}>
                        {book.IsActive ? 'Active' : 'Inactive'}
                      </span>
                    </td>
                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                      <div className="flex gap-2">
                        <button
                          onClick={() => openEditModal(book)}
                          className="text-blue-600 hover:text-blue-900"
                          title="Edit"
                        >
                          <FontAwesomeIcon icon={faEdit} />
                        </button>
                        <button
                          onClick={() => openConfirmModal('delete', book.BookId)}
                          className="text-red-600 hover:text-red-900"
                          title="Delete"
                        >
                          <FontAwesomeIcon icon={faTrash} />
                        </button>
                        <button
                          onClick={() => openConfirmModal('toggle', book.BookId)}
                          className={book.IsActive ? "text-amber-600 hover:text-amber-900" : "text-green-600 hover:text-green-900"}
                          title={book.IsActive ? "Deactivate" : "Activate"}
                        >
                          <FontAwesomeIcon icon={book.IsActive ? faEyeSlash : faEye} />
                        </button>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          )}
        </div>
      </div>

      {/* Add/Edit Book Modal */}
      {isModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div 
            ref={modalRef}
            className="bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto"
          >
            <div className="p-6">
              <h3 className="text-lg font-semibold mb-4">
                {currentBook?.BookId ? 'Edit Book' : 'Add New Book'}
              </h3>
              
              <form onSubmit={handleSubmit} className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Left Column */}
                <div className="space-y-4">
                  {/* Book Photo */}
                  <div className="flex flex-col items-center">
                    <div className="relative mb-4">
                      {photoPreview ? (
                        <div className="relative">
                          <img 
                            src={photoPreview} 
                            alt="Book cover" 
                            className="h-48 w-36 object-cover rounded border border-gray-300"
                          />
                          <button
                            type="button"
                            onClick={removePhoto}
                            className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center"
                          >
                            Ã—
                          </button>
                        </div>
                      ) : (
                        <div className="h-48 w-36 bg-gray-200 rounded border border-gray-300 flex items-center justify-center">
                          <FontAwesomeIcon icon={faImage} className="text-gray-400 text-4xl" />
                        </div>
                      )}
                    </div>
                    <input
                      type="file"
                      ref={fileInputRef}
                      onChange={handlePhotoChange}
                      accept="image/*"
                      className="hidden"
                      id="bookPhoto"
                    />
                    <label
                      htmlFor="bookPhoto"
                      className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md cursor-pointer flex items-center gap-2"
                    >
                      <FontAwesomeIcon icon={faImage} /> Upload Cover
                    </label>
                  </div>

                  {/* Basic Info */}
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        <FontAwesomeIcon icon={faBook} className="mr-2 text-gray-500" />
                        Title *
                      </label>
                      <input
                        type="text"
                        value={currentBook?.Title || ''}
                        onChange={(e) => setCurrentBook({...currentBook, Title: e.target.value})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        <FontAwesomeIcon icon={faBarcode} className="mr-2 text-gray-500" />
                        ISBN *
                      </label>
                      <input
                        type="text"
                        value={currentBook?.IsbnNumber || ''}
                        onChange={(e) => setCurrentBook({...currentBook, IsbnNumber: e.target.value})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        <FontAwesomeIcon icon={faBarcode} className="mr-2 text-gray-500" />
                        Barcode
                      </label>
                      <input
                        type="text"
                        value={currentBook?.Barcode || ''}
                        onChange={(e) => setCurrentBook({...currentBook, Barcode: e.target.value})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        <FontAwesomeIcon icon={faUser} className="mr-2 text-gray-500" />
                        Author
                      </label>
                      <input
                        type="text"
                        value={currentBook?.Author || ''}
                        onChange={(e) => setCurrentBook({...currentBook, Author: e.target.value})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    </div>
                  </div>
                </div>

                {/* Right Column */}
                <div className="space-y-4">
                  {/* Course and Subject */}
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Course
                      </label>
                      <select
                        value={currentBook?.CourseId || ''}
                        onChange={handleCourseChange}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      >
                        <option value="">Select Course</option>
                        {courses.map((course) => (
                          <option key={course.id} value={course.id}>{course.courseName}</option>
                        ))}
                      </select>
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Subject
                      </label>
                      <select
                        value={currentBook?.SubjectId || ''}
                        onChange={(e) => setCurrentBook({...currentBook, SubjectId: parseInt(e.target.value) || undefined})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      >
                        <option value="">Select Subject</option>
                        {filteredSubjects.map((subject) => (
                          <option key={subject.SubId} value={subject.SubId}>{subject.Name}</option>
                        ))}
                      </select>
                    </div>
                  </div>

                  {/* Publication and Price */}
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Publication
                      </label>
                      <select
                        value={currentBook?.PublicationId || ''}
                        onChange={(e) => setCurrentBook({...currentBook, PublicationId: parseInt(e.target.value) || undefined})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      >
                        <option value="">Select Publication</option>
                        {publications.map((pub) => (
                          <option key={pub.PubId} value={pub.PubId}>{pub.Name}</option>
                        ))}
                      </select>
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        <FontAwesomeIcon icon={faMoneyBillWave} className="mr-2 text-gray-500" />
                        Price
                      </label>
                      <input
                        type="number"
                        value={currentBook?.Price || ''}
                        onChange={(e) => setCurrentBook({...currentBook, Price: parseFloat(e.target.value) || undefined})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        step="0.01"
                        min="0"
                      />
                    </div>
                  </div>

                  {/* Edition, Language, Year */}
                  <div className="grid grid-cols-3 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Edition
                      </label>
                      <input
                        type="text"
                        value={currentBook?.Edition || ''}
                        onChange={(e) => setCurrentBook({...currentBook, Edition: e.target.value})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        <FontAwesomeIcon icon={faLanguage} className="mr-2 text-gray-500" />
                        Language
                      </label>
                      <input
                        type="text"
                        value={currentBook?.Language || ''}
                        onChange={(e) => setCurrentBook({...currentBook, Language: e.target.value})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        <FontAwesomeIcon icon={faCalendar} className="mr-2 text-gray-500" />
                        Published Year
                      </label>
                      <input
                        type="number"
                        value={currentBook?.PublishedYear || ''}
                        onChange={(e) => setCurrentBook({...currentBook, PublishedYear: parseInt(e.target.value) || undefined})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        min="1900"
                        max={new Date().getFullYear()}
                      />
                    </div>
                  </div>

                  {/* Copies */}
                  <div className="grid grid-cols-2 gap-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Total Copies
                      </label>
                      <input
                        type="number"
                        value={currentBook?.TotalCopies || 1}
                        onChange={(e) => {
                          const total = parseInt(e.target.value) || 1;
                          setCurrentBook({
                            ...currentBook, 
                            TotalCopies: total,
                            AvailableCopies: total - ((currentBook?.TotalCopies || 1) - (currentBook?.AvailableCopies || 1))
                          });
                        }}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        min="1"
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Available Copies
                      </label>
                      <input
                        type="number"
                        value={currentBook?.AvailableCopies || 1}
                        onChange={(e) => setCurrentBook({...currentBook, AvailableCopies: parseInt(e.target.value) || 1})}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        min="0"
                        max={currentBook?.TotalCopies || 1}
                      />
                    </div>
                  </div>

                  {/* Details */}
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      <FontAwesomeIcon icon={faInfoCircle} className="mr-2 text-gray-500" />
                      Details
                    </label>
                    <textarea
                      value={currentBook?.Details || ''}
                      onChange={(e) => setCurrentBook({...currentBook, Details: e.target.value})}
                      className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      rows={3}
                    />
                  </div>

                  {/* Status (for edit mode) */}
                  {currentBook?.BookId && (
                    <div>
                      <label className="inline-flex items-center">
                        <input
                          type="checkbox"
                          checked={currentBook?.IsActive || false}
                          onChange={(e) => setCurrentBook({...currentBook, IsActive: e.target.checked})}
                          className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                        <span className="ml-2 text-sm text-gray-700">Active</span>
                      </label>
                    </div>
                  )}
                </div>

                {/* Form Actions */}
                <div className="md:col-span-2 flex justify-end gap-4 pt-4 border-t border-gray-200">
                  <button
                    type="button"
                    onClick={() => setIsModalOpen(false)}
                    className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
                  >
                    Cancel
                  </button>
                  <button
                    type="submit"
                    className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
                  >
                    {currentBook?.BookId ? 'Update Book' : 'Add Book'}
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
      )}

      {/* Confirmation Modal */}
      {isConfirmModalOpen && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
          <div 
            ref={confirmModalRef}
            className="bg-white rounded-lg shadow-xl p-6 max-w-sm w-full"
          >
            <h3 className="text-lg font-semibold mb-4">Confirm Action</h3>
            <p className="mb-6">
              {confirmAction === 'delete' 
                ? 'Are you sure you want to delete this book? This action cannot be undone.' 
                : 'Are you sure you want to change the status of this book?'}
            </p>
            <div className="flex justify-end gap-3">
              <button
                onClick={() => setIsConfirmModalOpen(false)}
                className="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
              >
                Cancel
              </button>
              <button
                onClick={handleConfirmAction}
                className={`px-4 py-2 text-white rounded-md ${
                  confirmAction === 'delete' 
                    ? 'bg-red-600 hover:bg-red-700' 
                    : 'bg-blue-600 hover:bg-blue-700'
                }`}
              >
                {confirmAction === 'delete' ? 'Delete' : 'Confirm'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default BooksPage;
------------------------------------------------------------------------------------------------------------

user of  multer 

import { NextRequest, NextResponse } from 'next/server';
import { getConnection } from '@/app/lib/db';
import logger from '@/app/lib/logger';
import fs from 'fs';
import path from 'path';
import multer from 'multer';
import { promisify } from 'util';

// Configure Multer storage
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadDir = path.join(process.cwd(), 'public', 'books');
    // Create directory if it doesn't exist
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    const extension = path.extname(file.originalname);
    cb(null, `book-${uniqueSuffix}${extension}`);
  }
});

// Initialize Multer
const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB file size limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed!'));
    }
  }
});

// Promisify Multer functions for use with Next.js API routes
const uploadSingle = promisify(upload.single('BookPhoto'));

export const config = {
  api: {
    bodyParser: false, // Disable default body parser to use Multer
  },
};

async function parseFormData(req: NextRequest) {
  return new Promise((resolve, reject) => {
    uploadSingle(req as any, {} as any, async (err: any) => {
      if (err) {
        return reject(err);
      }

      const formData = {
        ...(req as any).body,
        file: (req as any).file,
      };

      resolve(formData);
    });
  });
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const search = searchParams.get('search') || '';
    const status = searchParams.get('status') || 'all';
    const courseId = searchParams.get('courseId') || '';
    const subjectId = searchParams.get('subjectId') || '';
    const publicationId = searchParams.get('publicationId') || '';
    const availability = searchParams.get('availability') || 'all';

    const pool = await getConnection();
    
    let query = `
      SELECT b.*, 
        c.courseName AS CourseName,
        s.Name AS SubjectName,
        p.Name AS PublicationName
      FROM Books b
      LEFT JOIN Course c ON b.CourseId = c.id
      LEFT JOIN Subject s ON b.SubjectId = s.SubId
      LEFT JOIN Publication p ON b.PublicationId = p.PubId
      WHERE (b.Title LIKE @search OR b.IsbnNumber LIKE @search OR b.Author LIKE @search)
    `;
    
    const params: any = { 
      search: `%${search}%`,
      courseId: courseId ? parseInt(courseId) : null,
      subjectId: subjectId ? parseInt(subjectId) : null,
      publicationId: publicationId ? parseInt(publicationId) : null
    };

    if (status !== 'all') {
      query += ' AND b.IsActive = @isActive';
      params.isActive = status === 'active' ? 1 : 0;
    }

    if (courseId) {
      query += ' AND b.CourseId = @courseId';
    }

    if (subjectId) {
      query += ' AND b.SubjectId = @subjectId';
    }

    if (publicationId) {
      query += ' AND b.PublicationId = @publicationId';
    }

    if (availability !== 'all') {
      if (availability === 'available') {
        query += ' AND b.AvailableCopies > 0';
      } else {
        query += ' AND b.AvailableCopies = 0';
      }
    }

    query += ' ORDER BY b.Title';

    const result = await pool.request()
      .input('search', params.search)
      .input('isActive', params.isActive)
      .input('courseId', params.courseId)
      .input('subjectId', params.subjectId)
      .input('publicationId', params.publicationId)
      .query(query);

    return NextResponse.json(result.recordset);
  } catch (error) {
    logger.error(`Error fetching books: ${error}`);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    // Parse form data with Multer
    const formData: any = await parseFormData(req);
    
    const title = formData.Title;
    const isbnNumber = formData.IsbnNumber;
    const barcode = formData.Barcode;
    const author = formData.Author;
    const details = formData.Details;
    const courseId = formData.CourseId;
    const price = formData.Price;
    const subjectId = formData.SubjectId;
    const publicationId = formData.PublicationId;
    const totalCopies = formData.TotalCopies;
    const edition = formData.Edition;
    const language = formData.Language;
    const publishedYear = formData.PublishedYear;
    const createdBy = formData.CreatedBy || 'admin';
    const bookPhotoFile = formData.file;

    // Validate required fields
    if (!title || !isbnNumber) {
      // Clean up uploaded file if validation fails
      if (bookPhotoFile) {
        fs.unlinkSync(bookPhotoFile.path);
      }
      return NextResponse.json({ message: 'Title and ISBN are required' }, { status: 400 });
    }

    let bookPhotoPath = '';
    if (bookPhotoFile) {
      bookPhotoPath = `/books/${bookPhotoFile.filename}`;
    }

    const pool = await getConnection();
    
    // Check if ISBN already exists
    const checkResult = await pool.request()
      .input('IsbnNumber', isbnNumber)
      .query('SELECT * FROM Books WHERE IsbnNumber = @IsbnNumber');

    if (checkResult.recordset.length > 0) {
      // Clean up uploaded file if ISBN exists
      if (bookPhotoFile) {
        fs.unlinkSync(bookPhotoFile.path);
      }
      return NextResponse.json({ message: 'Book with this ISBN already exists' }, { status: 400 });
    }

    await pool.request()
      .input('IsbnNumber', isbnNumber)
      .input('Title', title)
      .input('Barcode', barcode || null)
      .input('Author', author || null)
      .input('BookPhoto', bookPhotoPath || null)
      .input('Details', details || null)
      .input('CourseId', courseId ? parseInt(courseId) : null)
      .input('Price', price ? parseFloat(price) : null)
      .input('SubjectId', subjectId ? parseInt(subjectId) : null)
      .input('PublicationId', publicationId ? parseInt(publicationId) : null)
      .input('TotalCopies', totalCopies ? parseInt(totalCopies) : 1)
      .input('AvailableCopies', totalCopies ? parseInt(totalCopies) : 1)
      .input('Edition', edition || null)
      .input('Language', language || null)
      .input('PublishedYear', publishedYear ? parseInt(publishedYear) : null)
      .input('CreatedBy', createdBy)
      .query(`
        INSERT INTO Books (
          IsbnNumber, Title, Barcode, Author, BookPhoto, Details, CourseId, Price, 
          SubjectId, PublicationId, TotalCopies, AvailableCopies, Edition, 
          Language, PublishedYear, CreatedBy
        ) VALUES (
          @IsbnNumber, @Title, @Barcode, @Author, @BookPhoto, @Details, @CourseId, @Price,
          @SubjectId, @PublicationId, @TotalCopies, @AvailableCopies, @Edition,
          @Language, @PublishedYear, @CreatedBy
        )
      `);

    return NextResponse.json({ message: 'Book added successfully' });
  } catch (error: any) {
    logger.error(`Error adding book: ${error}`);
    return NextResponse.json({ 
      message: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    // Parse form data with Multer
    const formData: any = await parseFormData(req);
    
    const bookId = formData.BookId;
    const title = formData.Title;
    const isbnNumber = formData.IsbnNumber;
    const barcode = formData.Barcode;
    const author = formData.Author;
    const details = formData.Details;
    const courseId = formData.CourseId;
    const price = formData.Price;
    const subjectId = formData.SubjectId;
    const publicationId = formData.PublicationId;
    const totalCopies = formData.TotalCopies;
    const edition = formData.Edition;
    const language = formData.Language;
    const publishedYear = formData.PublishedYear;
    const modifiedBy = formData.ModifiedBy || 'admin';
    const isActive = formData.IsActive;
    const bookPhotoFile = formData.file;
    const currentPhotoPath = formData.CurrentPhotoPath;

    // Validate required fields
    if (!bookId || !title || !isbnNumber) {
      // Clean up uploaded file if validation fails
      if (bookPhotoFile) {
        fs.unlinkSync(bookPhotoFile.path);
      }
      return NextResponse.json({ message: 'Book ID, Title and ISBN are required' }, { status: 400 });
    }

    let bookPhotoPath = currentPhotoPath || '';
    if (bookPhotoFile) {
      // Delete old photo if exists
      if (currentPhotoPath) {
        const oldFilePath = path.join(process.cwd(), 'public', currentPhotoPath);
        if (fs.existsSync(oldFilePath)) {
          fs.unlinkSync(oldFilePath);
        }
      }
      bookPhotoPath = `/books/${bookPhotoFile.filename}`;
    }

    const pool = await getConnection();
    
    // Check if ISBN already exists for another book
    const checkResult = await pool.request()
      .input('IsbnNumber', isbnNumber)
      .input('BookId', parseInt(bookId))
      .query('SELECT * FROM Books WHERE IsbnNumber = @IsbnNumber AND BookId != @BookId');

    if (checkResult.recordset.length > 0) {
      // Clean up uploaded file if ISBN exists
      if (bookPhotoFile) {
        fs.unlinkSync(bookPhotoFile.path);
      }
      return NextResponse.json({ message: 'Another book with this ISBN already exists' }, { status: 400 });
    }

    await pool.request()
      .input('BookId', parseInt(bookId))
      .input('IsbnNumber', isbnNumber)
      .input('Title', title)
      .input('Barcode', barcode || null)
      .input('Author', author || null)
      .input('BookPhoto', bookPhotoPath || null)
      .input('Details', details || null)
      .input('CourseId', courseId ? parseInt(courseId) : null)
      .input('Price', price ? parseFloat(price) : null)
      .input('SubjectId', subjectId ? parseInt(subjectId) : null)
      .input('PublicationId', publicationId ? parseInt(publicationId) : null)
      .input('TotalCopies', totalCopies ? parseInt(totalCopies) : 1)
      .input('Edition', edition || null)
      .input('Language', language || null)
      .input('PublishedYear', publishedYear ? parseInt(publishedYear) : null)
      .input('ModifiedBy', modifiedBy)
      .input('IsActive', isActive === 'true' ? 1 : 0)
      .query(`
        UPDATE Books SET
          IsbnNumber = @IsbnNumber,
          Title = @Title,
          Barcode = @Barcode,
          Author = @Author,
          BookPhoto = @BookPhoto,
          Details = @Details,
          CourseId = @CourseId,
          Price = @Price,
          SubjectId = @SubjectId,
          PublicationId = @PublicationId,
          TotalCopies = @TotalCopies,
          Edition = @Edition,
          Language = @Language,
          PublishedYear = @PublishedYear,
          ModifiedBy = @ModifiedBy,
          ModifiedOn = GETDATE(),
          IsActive = @IsActive
        WHERE BookId = @BookId
      `);

    return NextResponse.json({ message: 'Book updated successfully' });
  } catch (error: any) {
    logger.error(`Error updating book: ${error}`);
    return NextResponse.json({ 
      message: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}

export async function DELETE(req: NextRequest) {
  try {
    const { BookId } = await req.json();
    
    if (!BookId) {
      return NextResponse.json({ message: 'Book ID is required' }, { status: 400 });
    }

    const pool = await getConnection();
    
    // First get the book photo path to delete it
    const bookResult = await pool.request()
      .input('BookId', BookId)
      .query('SELECT BookPhoto FROM Books WHERE BookId = @BookId');

    if (bookResult.recordset.length === 0) {
      return NextResponse.json({ message: 'Book not found' }, { status: 404 });
    }

    const bookPhotoPath = bookResult.recordset[0].BookPhoto;
    
    // Delete the photo if exists
    if (bookPhotoPath) {
      try {
        const filePath = path.join(process.cwd(), 'public', bookPhotoPath);
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
      } catch (error) {
        logger.error(`Error deleting book photo: ${error}`);
        // Continue with book deletion even if photo deletion fails
      }
    }

    // Delete the book
    await pool.request()
      .input('BookId', BookId)
      .query('DELETE FROM Books WHERE BookId = @BookId');

    return NextResponse.json({ message: 'Book deleted successfully' });
  } catch (error) {
    logger.error(`Error deleting book: ${error}`);
    return NextResponse.json({ message: 'Internal server error' }, { status: 500 });
  }
}
----------------------------------------------------------------

// src/app/api/admin/api/book/route.ts

export async function POST(req: NextRequest) {
  try {
    // Parse form data with Multer
    const formData: any = await parseFormData(req);
    
    // Debugging: Log the form data received
    console.log('Form data received:', formData);

    // Extract fields with proper null checks
    const title = formData.Title?.trim() || '';
    const isbnNumber = formData.IsbnNumber?.trim() || '';
    const barcode = formData.Barcode?.trim() || null;
    const author = formData.Author?.trim() || null;
    const details = formData.Details?.trim() || null;
    const courseId = formData.CourseId ? parseInt(formData.CourseId) : null;
    const price = formData.Price ? parseFloat(formData.Price) : null;
    const subjectId = formData.SubjectId ? parseInt(formData.SubjectId) : null;
    const publicationId = formData.PublicationId ? parseInt(formData.PublicationId) : null;
    const totalCopies = formData.TotalCopies ? parseInt(formData.TotalCopies) : 1;
    const edition = formData.Edition?.trim() || null;
    const language = formData.Language?.trim() || null;
    const publishedYear = formData.PublishedYear ? parseInt(formData.PublishedYear) : null;
    const createdBy = formData.CreatedBy?.trim() || 'admin';
    const bookPhotoFile = formData.file;

    // Validate required fields
    if (!title) {
      if (bookPhotoFile) fs.unlinkSync(bookPhotoFile.path);
      return NextResponse.json({ message: 'Title is required' }, { status: 400 });
    }

    if (!isbnNumber) {
      if (bookPhotoFile) fs.unlinkSync(bookPhotoFile.path);
      return NextResponse.json({ message: 'ISBN is required' }, { status: 400 });
    }

    // Additional ISBN validation
    if (isbnNumber.length < 10 || isbnNumber.length > 20) {
      if (bookPhotoFile) fs.unlinkSync(bookPhotoFile.path);
      return NextResponse.json({ message: 'ISBN must be between 10 and 20 characters' }, { status: 400 });
    }

    let bookPhotoPath = '';
    if (bookPhotoFile) {
      bookPhotoPath = `/books/${bookPhotoFile.filename}`;
    }

    const pool = await getConnection();
    
    // Check if ISBN already exists
    const checkResult = await pool.request()
      .input('IsbnNumber', isbnNumber)
      .query('SELECT * FROM Books WHERE IsbnNumber = @IsbnNumber');

    if (checkResult.recordset.length > 0) {
      if (bookPhotoFile) fs.unlinkSync(bookPhotoFile.path);
      return NextResponse.json({ message: 'Book with this ISBN already exists' }, { status: 400 });
    }

    // Insert the book
    await pool.request()
      .input('IsbnNumber', isbnNumber)
      .input('Title', title)
      .input('Barcode', barcode)
      .input('Author', author)
      .input('BookPhoto', bookPhotoPath)
      .input('Details', details)
      .input('CourseId', courseId)
      .input('Price', price)
      .input('SubjectId', subjectId)
      .input('PublicationId', publicationId)
      .input('TotalCopies', totalCopies)
      .input('AvailableCopies', totalCopies)
      .input('Edition', edition)
      .input('Language', language)
      .input('PublishedYear', publishedYear)
      .input('CreatedBy', createdBy)
      .query(`
        INSERT INTO Books (
          IsbnNumber, Title, Barcode, Author, BookPhoto, Details, CourseId, Price, 
          SubjectId, PublicationId, TotalCopies, AvailableCopies, Edition, 
          Language, PublishedYear, CreatedBy
        ) VALUES (
          @IsbnNumber, @Title, @Barcode, @Author, @BookPhoto, @Details, @CourseId, @Price,
          @SubjectId, @PublicationId, @TotalCopies, @AvailableCopies, @Edition,
          @Language, @PublishedYear, @CreatedBy
        )
      `);

    return NextResponse.json({ message: 'Book added successfully' });
  } catch (error: any) {
    logger.error(`Error adding book: ${error}`);
    return NextResponse.json({ 
      message: error.message || 'Internal server error' 
    }, { status: 500 });
  }
}
-------------------------------------------------------------------
// src/app/admin/book/page.tsx

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  
  // Validate required fields
  if (!currentBook?.Title?.trim()) {
    toast.error('Title is required');
    return;
  }

  if (!currentBook?.IsbnNumber?.trim()) {
    toast.error('ISBN is required');
    return;
  }

  // Additional validation
  if (currentBook.IsbnNumber.trim().length < 10 || currentBook.IsbnNumber.trim().length > 20) {
    toast.error('ISBN must be between 10 and 20 characters');
    return;
  }

  const formData = new FormData();
  
  // Append all fields with proper checks
  formData.append('Title', currentBook.Title.trim());
  formData.append('IsbnNumber', currentBook.IsbnNumber.trim());
  
  if (currentBook.Barcode?.trim()) formData.append('Barcode', currentBook.Barcode.trim());
  if (currentBook.Author?.trim()) formData.append('Author', currentBook.Author.trim());
  if (currentBook.Details?.trim()) formData.append('Details', currentBook.Details.trim());
  if (currentBook.CourseId) formData.append('CourseId', currentBook.CourseId.toString());
  if (currentBook.Price) formData.append('Price', currentBook.Price.toString());
  if (currentBook.SubjectId) formData.append('SubjectId', currentBook.SubjectId.toString());
  if (currentBook.PublicationId) formData.append('PublicationId', currentBook.PublicationId.toString());
  
  formData.append('TotalCopies', (currentBook.TotalCopies || 1).toString());
  formData.append('Edition', currentBook.Edition?.trim() || '');
  formData.append('Language', currentBook.Language?.trim() || '');
  
  if (currentBook.PublishedYear) formData.append('PublishedYear', currentBook.PublishedYear.toString());
  
  formData.append('CreatedBy', 'admin');
  
  if (currentBook.BookId) {
    formData.append('BookId', currentBook.BookId.toString());
    formData.append('ModifiedBy', 'admin');
    formData.append('IsActive', currentBook.IsActive?.toString() || 'true');
    if (currentBook.BookPhoto) formData.append('CurrentPhotoPath', currentBook.BookPhoto);
  }

  if (photoFile) {
    formData.append('BookPhoto', photoFile);
  }

  try {
    const method = currentBook.BookId ? 'put' : 'post';
    const res = await axios({
      method,
      url: '/api/book',
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    });

    toast.success(res.data.message);
    setIsModalOpen(false);
    fetchBooks();
  } catch (error: any) {
    const errorMsg = error.response?.data?.message || 'An error occurred';
    toast.error(errorMsg);
    
    // Log detailed error for debugging
    console.error('Error details:', {
      error: error.response?.data,
      requestData: {
        title: currentBook.Title,
        isbn: currentBook.IsbnNumber,
        // Include other relevant fields
      }
    });
  }
};
